module AtomFib
  ( compileFib )
where

import Language.Atom

-- | Invoke the atom compiler, generating 'fibDev.{c,h}' and 'fibDrv.{c,h}'.
-- Also print out info on the generated schedules.
--
-- The {c,h} files generated need to be compiled with the included
-- 'main.c' and 'main.h'. See the 'Makefile' for more details.
compileFib :: IO ()
compileFib = do
  (devSched, _, _, _, _) <- compile "fibDev" cfgDev fibDev
  (dvrSched, _, _, _, _) <- compile "fibDvr" cfgDvr fibDvr
  putStrLn $ reportSchedule devSched
  putStrLn $ reportSchedule dvrSched
  where
    cfgDev = defaults { cCode = prePostCCode, cStateName = "state_dev" }
    cfgDvr = defaults { cCode = prePostCCode, cStateName = "state_dvr" }

-- | Custom pre-post code for generated C
prePostCCode :: [Name] -> [Name] -> [(Name, Type)] -> (String, String)
prePostCCode _ _ _ =
  ( unlines [ "#include <stdbool.h>"
            , "#include <stdio.h>"
            , "#include \"main.h\""
            , ""
            , "// ---- This source is automatically generated by Atom ----"
            ]
  , unlines [ "// ---- This source is automatically generated by Atom ----"
            ]
  )

-- Fibonacci device: takes an index x from an external client and returns
-- fib(x).
fibDev :: Atom ()
fibDev = period 3 $ do
  fstf <- word64 "fstf" 1  -- fib(0)
  sndf <- word64 "sndf" 1  -- fib(1)
  ans  <- word64 "ans" 0   -- answer returned
  i    <- word64 "i" 0     -- local copy of received index
  runFib <- bool "runFib" False  -- computing fib(i)?

  -- external signals
  let x        = word64' "x"       -- index value from driver
  let newInd   = bool' "newInd"    -- index from driver ready
  let ansReady = bool' "ansReady"  -- fib(i) computed?
  let valRcvd  = bool' "valRcvd"   -- ack that the index is received


  -- wait for a new index from the client
  atom "getIndex" $ do
    cond $ not_ (value runFib)
    cond $ value newInd
    action (\xs -> "printf(\"fibDev.getIndex: x = %llu\\n\", " ++ (head xs) ++ ")")
           [ue . value $ x]
    i        <== value x
    runFib   <== true
    fstf     <== 1
    sndf     <== 1
    ansReady <== false
    valRcvd  <== true

  -- generate fib(i)
  atom "computeFib" $ do
    cond $ value runFib
    cond $ value i >. 0
    action (\xs -> "printf(\"fibDev.computeFib: i = %llu\\n\", " ++ (head xs) ++ ")")
           [ue . value $ i]
    decr i
    sndf <== (value fstf) + (value sndf)
    fstf <== value sndf

  -- send fib(i) back to the client
  atom "sendVal" $ do
    cond $ value i ==. 0
    cond $ value runFib
    action (\xs -> "printf(\"fibDev.sendVal: ans <== %llu\\n\", " ++ (head xs) ++ ")")
           [ue . value $ fstf]
    runFib   <== false
    ans      <== value fstf
    ansReady <== true
    valRcvd  <== false

-- Fibonacci driver: generate a new index x and wait to receive fib(x).
fibDvr :: Atom ()
fibDvr = period 20 $ do

  -- external signals
  let x        = word64' "x"         -- new index to send
  let valRcvd  = bool'   "valRcvd"   -- has the device received the new index?
  let ans      = word64' "ans"       -- the newly-computed fib(x)
  let ansReady = bool'   "ansReady"  -- is an answer waiting?

  oldInd  <- word64 "oldInd" 0    -- previous index sent
  valD    <- word64 "valD" 1      -- local copy of fib(x)
  newInd  <- bool "newInd" True   -- a new index is ready
  waiting <- bool "waiting" True  -- waiting for a new computation

  atom "wait" $ do
    cond $ value valRcvd
    cond $ not_ $ value waiting
    action (\_ -> "printf(\"fibDvr.wait\\n\")") []
    newInd  <== false
    waiting <== true

  atom "getAns" $ do
    cond $ value ansReady
    cond $ value waiting
    cond $ value x <. 50
    action
      (\xs -> "printf(\"fibDvr.getAns: *[received]* ans <== %llu\\n\", " ++
              (head xs) ++ ")")
      [ue . value $ ans]
    valD    <== value ans
    x       <== value x + 5
    waiting <== false
    newInd  <== true
    oldInd  <== value x
